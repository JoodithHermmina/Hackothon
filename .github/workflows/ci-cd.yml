name: CI/CD Pipeline

# Testing AWS Secrets Manager Integration with OIDC Authentication
# OIDC Provider: token.actions.githubusercontent.com
# IAM Role: github-actions-oidc-role
# Trigger: Final verification of complete AWS Secrets Manager and OIDC configuration
# Last updated: $(date)
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Add permissions needed for OIDC
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-south-1
  SECRET_NAME: resume-builder/dev/app-secrets
  REQUIRED_SECRETS: "AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_ACCOUNT_ID APP_DOMAIN"

jobs:
  # test:
  #   name: Test Applications
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Check out the repo
  #     uses: actions/checkout@v3

  #   - name: Set up Python for backend tests
  #     uses: actions/setup-python@v4
  #     with:
  #       python-version: '3.10'

  #   - name: Install LaTeX dependencies
  #     run: |
  #       sudo apt-get update
  #       sudo apt-get install -y texlive-latex-base texlive-fonts-recommended texlive-fonts-extra texlive-latex-extra

  #   - name: Install backend dependencies
  #     run: |
  #       cd Resume-Backend
  #       python -m pip install --upgrade pip
  #       pip install -r requirements.txt
  #       pip install pytest pytest-cov

  #   - name: Run backend tests
  #     run: |
  #       cd Resume-Backend
  #       # Create necessary directories for tests
  #       mkdir -p templates static
  #       cp templates/twks_resume_template.tex templates/ || true
  #       cp company_logo.png templates/ || true
  #       pytest tests/ --cov=.

  #   - name: Set up Node.js for frontend tests
  #     uses: actions/setup-node@v3
  #     with:
  #       node-version: '18'

  #   - name: Install frontend dependencies
  #     run: |
  #       cd resume-frontend
  #       npm install --legacy-peer-deps

  #   - name: Run frontend tests
  #     run: |
  #       cd resume-frontend
  #       CI=true npm test -- --passWithNoTests

  build_and_push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    # needs: test  # Comment out the dependency on test job
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Check out the repo
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::565393046834:role/github-actions-oidc-role
        aws-region: ${{ env.AWS_REGION }}
        audience: sts.amazonaws.com

    - name: Get AWS credentials from Secrets Manager
      id: get-aws-credentials
      run: |
        echo "Attempting to retrieve secrets from AWS Secrets Manager..."
        
        # Function to validate required secrets
        validate_secrets() {
          local secrets_json="$1"
          local missing_secrets=()
          
          for secret in ${{ env.REQUIRED_SECRETS }}; do
            if ! echo "$secrets_json" | jq -e "has(\"$secret\")" > /dev/null; then
              missing_secrets+=("$secret")
            fi
          done
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
        }
        
        # Get secrets with error handling
        if ! SECRETS=$(aws secretsmanager get-secret-value \
          --secret-id "${{ env.SECRET_NAME }}" \
          --region "${{ env.AWS_REGION }}" \
          --query SecretString \
          --output text); then
          echo "Error: Failed to retrieve secrets from AWS Secrets Manager"
          exit 1
        fi
        
        # Validate JSON format
        if ! echo "$SECRETS" | jq empty; then
          echo "Error: Invalid JSON format in secrets"
          exit 1
        fi
        
        # Validate required secrets
        validate_secrets "$SECRETS"
        
        # Mask sensitive values
        echo "Masking sensitive values..."
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)"
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)"
        echo "::add-mask::$(echo $SECRETS | jq -r .APP_DOMAIN)"
        
        # Export AWS credentials for subsequent steps
        echo "Exporting credentials..."
        echo "aws_access_key_id=$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)" >> $GITHUB_OUTPUT
        echo "aws_secret_access_key=$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)" >> $GITHUB_OUTPUT
        echo "aws_account_id=$(echo $SECRETS | jq -r .AWS_ACCOUNT_ID)" >> $GITHUB_OUTPUT
        echo "app_domain=$(echo $SECRETS | jq -r .APP_DOMAIN)" >> $GITHUB_OUTPUT
        
        echo "Successfully retrieved and validated secrets"

    - name: Verify AWS credentials
      id: verify-credentials
      run: |
        echo "Verifying AWS credentials..."
        if ! aws sts get-caller-identity &>/dev/null; then
          echo "Error: Invalid AWS credentials"
          exit 1
        fi
        echo "AWS credentials verified successfully"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build and push backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: resume-backend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd Resume-Backend
        docker build \
          --build-arg FLASK_ENV=production \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Build and push frontend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: resume-frontend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd resume-frontend
        docker build \
          --build-arg REACT_APP_API_URL=http://${{ steps.get-aws-credentials.outputs.app_domain }} \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  terraform:
    name: Deploy with Terraform
    runs-on: ubuntu-latest
    needs: build_and_push
    if: (github.ref == 'refs/heads/main') && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
    - name: Check out the repo
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::565393046834:role/github-actions-oidc-role
        aws-region: ${{ env.AWS_REGION }}
        audience: sts.amazonaws.com

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.7

    - name: Get AWS credentials from Secrets Manager
      id: get-aws-credentials
      run: |
        echo "Attempting to retrieve secrets from AWS Secrets Manager..."
        
        # Function to validate required secrets
        validate_secrets() {
          local secrets_json="$1"
          local missing_secrets=()
          
          for secret in ${{ env.REQUIRED_SECRETS }}; do
            if ! echo "$secrets_json" | jq -e "has(\"$secret\")" > /dev/null; then
              missing_secrets+=("$secret")
            fi
          done
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
        }
        
        # Get secrets with error handling
        if ! SECRETS=$(aws secretsmanager get-secret-value \
          --secret-id "${{ env.SECRET_NAME }}" \
          --region "${{ env.AWS_REGION }}" \
          --query SecretString \
          --output text); then
          echo "Error: Failed to retrieve secrets from AWS Secrets Manager"
          exit 1
        fi
        
        # Validate JSON format
        if ! echo "$SECRETS" | jq empty; then
          echo "Error: Invalid JSON format in secrets"
          exit 1
        fi
        
        # Validate required secrets
        validate_secrets "$SECRETS"
        
        # Mask sensitive values
        echo "Masking sensitive values..."
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)"
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)"
        
        # Export AWS credentials for subsequent steps
        echo "Exporting credentials..."
        echo "aws_access_key_id=$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)" >> $GITHUB_OUTPUT
        echo "aws_secret_access_key=$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)" >> $GITHUB_OUTPUT
        echo "aws_account_id=$(echo $SECRETS | jq -r .AWS_ACCOUNT_ID)" >> $GITHUB_OUTPUT
        
        echo "Successfully retrieved and validated secrets"

    - name: Verify AWS credentials
      id: verify-credentials
      run: |
        echo "Verifying AWS credentials..."
        if ! aws sts get-caller-identity &>/dev/null; then
          echo "Error: Invalid AWS credentials"
          exit 1
        fi
        echo "AWS credentials verified successfully"

    - name: Create S3 bucket for Terraform state if not exists
      run: |
        aws s3api head-bucket --bucket resume-builder-tf-state 2>/dev/null || \
        aws s3 mb s3://resume-builder-tf-state --region ${{ env.AWS_REGION }}

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan -var "image_tag=${{ github.sha }}" -var "aws_region=${{ env.AWS_REGION }}"

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve -var "image_tag=${{ github.sha }}" -var "aws_region=${{ env.AWS_REGION }}"

    - name: Get Application URL
      run: |
        cd terraform
        echo "Application URL: $(terraform output -raw load_balancer_dns)"

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: terraform
    if: always()

    steps:
    - name: Send notification on success
      if: ${{ needs.terraform.result == 'success' }}
      run: |
        echo "Deployment succeeded! Application is now available."

    - name: Send notification on failure
      if: ${{ needs.terraform.result != 'success' }}
      run: |
        echo "Deployment failed. Please check the GitHub Actions logs."
