name: CI/CD Pipeline

# Testing AWS Secrets Manager Integration with OIDC Authentication
# OIDC Provider: token.actions.githubusercontent.com
# IAM Role: github-actions-oidc-role
# Trigger: Testing deployment with updated IAM role policy permissions
# Last updated: $(date '+%Y-%m-%d %H:%M:%S')
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Add permissions needed for OIDC
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'ap-south-1' }}
  SECRET_NAME: ${{ secrets.SECRET_NAME || 'resume-builder/dev/app-secrets' }}
  REQUIRED_SECRETS: "AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_ACCOUNT_ID APP_DOMAIN"
  IAM_ROLE: ${{ secrets.IAM_ROLE || 'github-actions-oidc-role' }}
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET || 'resume-builder-tf-state' }}
  APP_NAME: ${{ secrets.APP_NAME || 'resume-builder' }}
  ENVIRONMENT: ${{ secrets.ENVIRONMENT || 'dev' }}
  ALLOW_RESOURCE_DELETION: ${{ secrets.ALLOW_RESOURCE_DELETION || 'false' }}

jobs:
  # test:
  #   name: Test Applications
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Check out the repo
  #     uses: actions/checkout@v3

  #   - name: Set up Python for backend tests
  #     uses: actions/setup-python@v4
  #     with:
  #       python-version: '3.10'

  #   - name: Install LaTeX dependencies
  #     run: |
  #       sudo apt-get update
  #       sudo apt-get install -y texlive-latex-base texlive-fonts-recommended texlive-fonts-extra texlive-latex-extra

  #   - name: Install backend dependencies
  #     run: |
  #       cd Resume-Backend
  #       python -m pip install --upgrade pip
  #       pip install -r requirements.txt
  #       pip install pytest pytest-cov

  #   - name: Run backend tests
  #     run: |
  #       cd Resume-Backend
  #       # Create necessary directories for tests
  #       mkdir -p templates static
  #       cp templates/twks_resume_template.tex templates/ || true
  #       cp company_logo.png templates/ || true
  #       pytest tests/ --cov=.

  #   - name: Set up Node.js for frontend tests
  #     uses: actions/setup-node@v3
  #     with:
  #       node-version: '18'

  #   - name: Install frontend dependencies
  #     run: |
  #       cd resume-frontend
  #       npm install --legacy-peer-deps

  #   - name: Run frontend tests
  #     run: |
  #       cd resume-frontend
  #       CI=true npm test -- --passWithNoTests

  build_and_push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    # needs: test  # Comment out the dependency on test job
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Check out the repo
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ steps.get-aws-credentials.outputs.aws_account_id }}:role/${{ env.IAM_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        audience: sts.amazonaws.com

    - name: Get AWS credentials from Secrets Manager
      id: get-aws-credentials
      run: |
        echo "Attempting to retrieve secrets from AWS Secrets Manager..."
        
        # Function to validate required secrets
        validate_secrets() {
          local secrets_json="$1"
          local missing_secrets=()
          
          for secret in ${{ env.REQUIRED_SECRETS }}; do
            if ! echo "$secrets_json" | jq -e "has(\"$secret\")" > /dev/null; then
              missing_secrets+=("$secret")
            fi
          done
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
        }
        
        # Get secrets with error handling
        if ! SECRETS=$(aws secretsmanager get-secret-value \
          --secret-id "${{ env.SECRET_NAME }}" \
          --region "${{ env.AWS_REGION }}" \
          --query SecretString \
          --output text); then
          echo "Error: Failed to retrieve secrets from AWS Secrets Manager"
          exit 1
        fi
        
        # Validate JSON format
        if ! echo "$SECRETS" | jq empty; then
          echo "Error: Invalid JSON format in secrets"
          exit 1
        fi
        
        # Validate required secrets
        validate_secrets "$SECRETS"
        
        # Extract and validate AWS Account ID
        AWS_ACCOUNT_ID=$(echo "$SECRETS" | jq -r '.AWS_ACCOUNT_ID')
        if [[ ! "$AWS_ACCOUNT_ID" =~ ^[0-9]{12}$ ]]; then
          echo "Error: Invalid AWS Account ID format. Expected 12 digits."
          exit 1
        fi
        
        # Mask sensitive values
        echo "Masking sensitive values..."
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)"
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)"
        echo "::add-mask::$AWS_ACCOUNT_ID"
        
        # Export AWS credentials for subsequent steps
        echo "Exporting credentials..."
        {
          echo "aws_access_key_id=$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)"
          echo "aws_secret_access_key=$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)"
          echo "aws_account_id=$AWS_ACCOUNT_ID"
          echo "app_domain=$(echo $SECRETS | jq -r .APP_DOMAIN)"
        } >> $GITHUB_OUTPUT
        
        echo "Successfully retrieved and validated secrets"
        echo "AWS Account ID has been set in outputs"

    - name: Verify AWS credentials
      id: verify-credentials
      run: |
        echo "Verifying AWS credentials..."
        if ! aws sts get-caller-identity &>/dev/null; then
          echo "Error: Invalid AWS credentials"
          exit 1
        fi
        echo "AWS credentials verified successfully"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build and push backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: resume-backend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd Resume-Backend
        docker build \
          --build-arg FLASK_ENV=production \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Build and push frontend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: resume-frontend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd resume-frontend
        docker build \
          --build-arg REACT_APP_API_URL=http://${{ steps.get-aws-credentials.outputs.app_domain }} \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  terraform:
    name: Deploy with Terraform
    runs-on: ubuntu-latest
    needs: build_and_push
    if: (github.ref == 'refs/heads/main') && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
    - name: Check out the repo
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ steps.get-aws-credentials.outputs.aws_account_id }}:role/${{ env.IAM_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        audience: sts.amazonaws.com

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.7

    - name: Get AWS credentials from Secrets Manager
      id: get-aws-credentials
      run: |
        echo "Attempting to retrieve secrets from AWS Secrets Manager..."
        
        # Function to validate required secrets
        validate_secrets() {
          local secrets_json="$1"
          local missing_secrets=()
          
          for secret in ${{ env.REQUIRED_SECRETS }}; do
            if ! echo "$secrets_json" | jq -e "has(\"$secret\")" > /dev/null; then
              missing_secrets+=("$secret")
            fi
          done
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
        }
        
        # Get secrets with error handling
        if ! SECRETS=$(aws secretsmanager get-secret-value \
          --secret-id "${{ env.SECRET_NAME }}" \
          --region "${{ env.AWS_REGION }}" \
          --query SecretString \
          --output text); then
          echo "Error: Failed to retrieve secrets from AWS Secrets Manager"
          exit 1
        fi
        
        # Validate JSON format
        if ! echo "$SECRETS" | jq empty; then
          echo "Error: Invalid JSON format in secrets"
          exit 1
        fi
        
        # Validate required secrets
        validate_secrets "$SECRETS"
        
        # Extract and validate AWS Account ID
        AWS_ACCOUNT_ID=$(echo "$SECRETS" | jq -r '.AWS_ACCOUNT_ID')
        if [[ ! "$AWS_ACCOUNT_ID" =~ ^[0-9]{12}$ ]]; then
          echo "Error: Invalid AWS Account ID format. Expected 12 digits."
          exit 1
        fi
        
        # Mask sensitive values
        echo "Masking sensitive values..."
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)"
        echo "::add-mask::$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)"
        echo "::add-mask::$AWS_ACCOUNT_ID"
        
        # Export AWS credentials for subsequent steps
        echo "Exporting credentials..."
        {
          echo "aws_access_key_id=$(echo $SECRETS | jq -r .AWS_ACCESS_KEY_ID)"
          echo "aws_secret_access_key=$(echo $SECRETS | jq -r .AWS_SECRET_ACCESS_KEY)"
          echo "aws_account_id=$AWS_ACCOUNT_ID"
          echo "app_domain=$(echo $SECRETS | jq -r .APP_DOMAIN)"
        } >> $GITHUB_OUTPUT
        
        echo "Successfully retrieved and validated secrets"
        echo "AWS Account ID has been set in outputs"

    - name: Verify AWS credentials
      id: verify-credentials
      run: |
        echo "Verifying AWS credentials..."
        if ! aws sts get-caller-identity &>/dev/null; then
          echo "Error: Invalid AWS credentials"
          exit 1
        fi
        echo "AWS credentials verified successfully"

    - name: Create S3 bucket for Terraform state if not exists
      run: |
        echo "Checking if Terraform state bucket exists..."
        if ! aws s3api head-bucket --bucket ${{ env.TF_STATE_BUCKET }} 2>/dev/null; then
          echo "Creating Terraform state bucket..."
          if aws s3 mb s3://${{ env.TF_STATE_BUCKET }} --region ${{ env.AWS_REGION }}; then
            echo "Enabling versioning for state bucket..."
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_STATE_BUCKET }} \
              --versioning-configuration Status=Enabled
            
            echo "Adding bucket encryption..."
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_STATE_BUCKET }} \
              --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
          else
            echo "Failed to create state bucket. Check permissions and bucket name availability."
            exit 1
          fi
        else
          echo "State bucket already exists"
        fi

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      env:
        TF_VAR_aws_account_id: ${{ steps.get-aws-credentials.outputs.aws_account_id }}
        TF_VAR_environment: ${{ env.ENVIRONMENT || 'dev' }}
        TF_VAR_app_name: ${{ env.APP_NAME }}
        TF_VAR_tf_state_bucket: ${{ env.TF_STATE_BUCKET }}
        TF_VAR_ecr_repositories: '["resume-backend", "resume-frontend"]'
      run: |
        cd terraform
        
        # Validate AWS Account ID
        if [ -z "$TF_VAR_aws_account_id" ]; then
          echo "Error: AWS Account ID is not set"
          echo "Debugging information:"
          echo "get-aws-credentials step output: ${{ steps.get-aws-credentials.outputs.aws_account_id }}"
          echo "Current environment variables:"
          env | grep -i aws
          exit 1
        fi
        
        echo "Using AWS Account ID: $TF_VAR_aws_account_id"
        
        # Save plan to file for validation
        terraform plan \
          -var "aws_account_id=$TF_VAR_aws_account_id" \
          -var "image_tag=${{ github.sha }}" \
          -var "aws_region=${{ env.AWS_REGION }}" \
          -out=tfplan

    - name: Validate Terraform Configuration
      env:
        TF_VAR_aws_account_id: ${{ steps.get-aws-credentials.outputs.aws_account_id }}
        TF_VAR_environment: ${{ env.ENVIRONMENT || 'dev' }}
        TF_VAR_app_name: ${{ env.APP_NAME }}
        TF_VAR_tf_state_bucket: ${{ env.TF_STATE_BUCKET }}
        TF_VAR_ecr_repositories: '["resume-backend", "resume-frontend"]'
      run: |
        cd terraform
        
        echo "Running Terraform format check..."
        terraform fmt -check -recursive || {
          echo "Error: Terraform files are not properly formatted"
          terraform fmt -diff -recursive
          exit 1
        }
        
        echo "Running Terraform validation..."
        terraform validate || {
          echo "Error: Terraform configuration is invalid"
          exit 1
        }
        
        echo "Checking for sensitive data in Terraform files..."
        if grep -r -E "arn:aws|[0-9]{12}|aws_access_key|aws_secret_key" *.tf; then
          echo "Warning: Found potential sensitive data in Terraform files"
          exit 1
        fi
        
        echo "Analyzing Terraform plan..."
        terraform show -json tfplan > tfplan.json
        
        # Check for resource deletions
        if jq -e '.resource_changes[] | select(.change.actions[] | contains("delete"))' tfplan.json > /dev/null; then
          echo "Warning: Plan includes resource deletions. Please review carefully!"
          jq '.resource_changes[] | select(.change.actions[] | contains("delete")) | .address' tfplan.json
          echo "Do you want to continue? (Set ALLOW_RESOURCE_DELETION=true to proceed)"
          if [[ "${ALLOW_RESOURCE_DELETION}" != "true" ]]; then
            exit 1
          fi
        fi
        
        # Check for critical resource changes
        critical_resources=(
          "aws_ecs_service"
          "aws_ecs_cluster"
          "aws_ecr_repository"
          "aws_iam_role"
        )
        
        for resource in "${critical_resources[@]}"; do
          if jq -e --arg res "$resource" '.resource_changes[] | select(.type == $res and .change.actions[] | contains("update"))' tfplan.json > /dev/null; then
            echo "Warning: Plan includes changes to critical resource: $resource"
            jq --arg res "$resource" '.resource_changes[] | select(.type == $res and .change.actions[] | contains("update"))' tfplan.json
          fi
        done
        
        echo "Validation completed successfully!"

    - name: Terraform Apply
      if: success()
      env:
        TF_VAR_aws_account_id: ${{ steps.get-aws-credentials.outputs.aws_account_id }}
        TF_VAR_environment: ${{ env.ENVIRONMENT || 'dev' }}
        TF_VAR_app_name: ${{ env.APP_NAME }}
        TF_VAR_tf_state_bucket: ${{ env.TF_STATE_BUCKET }}
        TF_VAR_ecr_repositories: '["resume-backend", "resume-frontend"]'
      run: |
        cd terraform
        # Apply the validated plan
        terraform apply tfplan

    - name: Get Application URL
      run: |
        cd terraform
        echo "Application URL: $(terraform output -raw load_balancer_dns)"

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: terraform
    if: always()

    steps:
    - name: Send notification on success
      if: ${{ needs.terraform.result == 'success' }}
      run: |
        echo "Deployment succeeded! Application is now available."

    - name: Send notification on failure
      if: ${{ needs.terraform.result != 'success' }}
      run: |
        echo "Deployment failed. Please check the GitHub Actions logs."
